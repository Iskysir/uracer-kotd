PImage img;         // The initial lens flare object  (Put this image in your data folder and call it lensflare.png -> http://i.imgur.com/KhmWc.png)
PImage finalImage;  // The final image which we will blend over the base image

// Dimensions of the screen
int dimension = 512 * 262;

// Temporary layer to write silhouet on and for reading for the effect
color [] tempLayer = new color[dimension];

// Samples
int samples = 32;
float invSamples = 1.0f / (float)samples;

void setup()
{
  finalImage = loadImage("lensflare.png");
  img = loadImage("lensflare.png");
  dimension = img.width*img.height;

  tempLayer = new color[dimension];

  img.loadPixels();
  finalImage.loadPixels();

  size(img.width, img.height);
}

void draw()
{
  // Write our initial image to the tempLayer
  for(int i = 0; i < dimension; i++)
  {
    tempLayer[i] = img.pixels[i];
  }

  // Draw a black donut on the temp layer on the location of the mouse
  for(int y = 0; y < 128; y++)
  for(int x = 0; x < 128; x++)
  {
      int fx = mouseX - 64 + x;
      int fy = mouseY - 64 + y;

      if(fx < 0 || fx >= img.width) continue;
      if(fy < 0 || fy >= img.height) continue;

      int tx = x - 64;
      int ty = y - 64;

      // Donut radius 64 and 30.
      if(tx*tx+ty*ty < 64*64 && tx*tx+ty*ty > 30*30)
      {
          tempLayer[fx+fy*img.width] = 0;
      }
  }

  // Loop through the entire screen
  for(int y = 0; y < img.height; y++)
  for(int x = 0; x < img.width; x++)
  {
    // Start with black
    color totalColor = 0;

    // Calculate vector from this pixel to light source pixel [263, 171]
    float dx = 263 - (float)x;
    float dy = 171 - (float)y;

    for(int i = 0; i < samples; i++)
    {
      // Get the index for the sample color (turn this into bilinear sampling for better results)
      int indexX = (int)((float)x + (dx * ((float)i * invSamples)));
      int indexY = (int)((float)y + (dy * ((float)i * invSamples)));

      // Get the color
      color sampleColor = tempLayer[indexX + indexY * img.width];

      // Extract components (divide sample by amount of samples)
      int a = (int)((float)((sampleColor >> 24)   & 0xFF) * invSamples);
      int r = (int)((float)((sampleColor >> 16)   & 0xFF) * invSamples);
      int g = (int)((float)((sampleColor >> 8)    & 0xFF) * invSamples);
      int b = (int)((float)(sampleColor           & 0xFF) * invSamples);

      // Add them to the total color
      a = ((totalColor >> 24) & 0xFF) + a;
      r = ((totalColor >> 16) & 0xFF) + r;
      g = ((totalColor >> 8) & 0xFF)  + g;
      b = (totalColor & 0xFF)         + b;

      // Set the actual color
      totalColor = color(r, g, b, a);
    }

    // Finally set the resulting pixel
    finalImage.pixels[x + y * img.width] = totalColor;
  }

  // Update the image
  finalImage.updatePixels();

  // Draw the image on the screen
  image(finalImage, 0, 0);
}